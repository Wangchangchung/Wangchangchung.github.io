<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java垃圾收集算法 | Charse Wan&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本篇文章主要讲解java中的主要几种垃圾收集算法思想，不讨论它的具体实现过程，因为垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java垃圾收集算法">
<meta property="og:url" content="http://yoursite.com/2016/08/19/Java垃圾收集算法/index.html">
<meta property="og:site_name" content="Charse Wan's Blog">
<meta property="og:description" content="本篇文章主要讲解java中的主要几种垃圾收集算法思想，不讨论它的具体实现过程，因为垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同。">
<meta property="og:image" content="http://yoursite.com/img/MarkClear.jpg">
<meta property="og:image" content="http://yoursite.com/picture/CopyShuanfa.png">
<meta property="og:image" content="http://yoursite.com/picture/MarkXZhengLi.png">
<meta property="og:updated_time" content="2016-08-20T08:45:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java垃圾收集算法">
<meta name="twitter:description" content="本篇文章主要讲解java中的主要几种垃圾收集算法思想，不讨论它的具体实现过程，因为垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同。">
<meta name="twitter:image" content="http://yoursite.com/img/MarkClear.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Charse Wan&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Charse Wan&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java垃圾收集算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/19/Java垃圾收集算法/" class="article-date">
  <time datetime="2016-08-19T03:11:45.000Z" itemprop="datePublished">2016-08-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM-Java/">JVM, Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java垃圾收集算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要讲解java中的主要几种垃圾收集算法思想，不讨论它的具体实现过程，因为垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同。<br><a id="more"></a></p>
<h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a><strong>1. 标记-清除算法</strong></h3><h4 id="1-1-算法思想"><a href="#1-1-算法思想" class="headerlink" title="1.1  算法思想"></a><strong>1.1  算法思想</strong></h4><p>“标记-清除”(Mark-Sweep)算法是最基础的垃圾收集算法，我们可以顾名思义，大概知道它的算法分为”标记”和”清除”， 这个算法的思想的确也是这样的，这个算法分为”标记”和”清除”两个阶段：首先，标记所有要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是前文《Java的垃圾收集机制》中的对对象标记判定的过程，之所以说这个算法是最基础的算法，是因为后续的算法是基于这个”标记-清除”算法的对其中的不足进行改进的。<br>标记-清除算法的执行过程如下图:<br><img src="/img/MarkClear.jpg" alt="1"></p>
<h4 id="1-2-算法缺点"><a href="#1-2-算法缺点" class="headerlink" title="1.2 算法缺点"></a><strong>1.2 算法缺点</strong></h4><p>它的主要不足之处有两点:</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不太高的。</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致在以后程序运行过程中需要分配较大对象的时候，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集的动作。</li>
</ul>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a><strong>2. 复制算法</strong></h3><h4 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a><strong>2.1 算法思想</strong></h4><p>复制算法的出现是为了解决”标记-清除”算法的效率问题，它将可用的内存按照容量大小分为大小相等的两块，每次只使用其中的一块当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把使用过的内存空间一次清理掉。这样使得每一次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂问题，只要移动堆顶指针，按顺序分配内存即可。复制算法的执行过程如下图：</p>
<p><img src="/picture/CopyShuanfa.png" alt="复制算法示意图"></p>
<h4 id="2-2-算法优点"><a href="#2-2-算法优点" class="headerlink" title="2.2 算法优点"></a><strong>2.2 算法优点</strong></h4><ul>
<li>解决”标记-清除”算法中的效率问题，实现简单，运行高效。</li>
</ul>
<p><strong>现在的商业虚拟机都采用这种收集算法回收新生代</strong>，IBM公司研究表明，新生代中的对象98%是”朝生夕死”的，所以没有必要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收的时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间，HotSpot默认使用Eden和Survrivor的大小比例为8：1，也就是说：每次新生代中可用内存空间为整个新生代容量的90%（80% + 10%），只有10%的内存空间会被”浪费”，当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Surviror空间不够用时，需要依赖其他内存(这里是指老年代)进行分配担保(Handle Promotion).</p>
<p>内存的分配担保就好比我们去银行借款，如果我们信誉好，在98%的情况下都能按时还款，那么银行可能会默认我们下一次也能按时按量的偿还贷款，只需要有一个担保人能够保证我不能还款时，可以从他的账户中扣钱，那么银行就认为没有风险了，内存的分配担保也一样，如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。关于新生代进行分配担保的内容，在后面介绍垃圾收集器执行规则的时候再细说。</p>
<h4 id="2-3-算法缺点"><a href="#2-3-算法缺点" class="headerlink" title="2.3 算法缺点"></a><strong>2.3 算法缺点</strong></h4><ul>
<li>在对象存活率较高时，就要进行较多的复制操作，效率将会变低。</li>
<li>将内存缩小到原来的一半，消耗比较高。如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选择这中算法。</li>
</ul>
<h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a><strong>3. 标记-整理算法</strong></h3><p>根据复制算法的不足之处，和老年代的特点，于是提出”标记-整理”算法(Mark-Compact)，标记过程和”标记-清除”算法一样，但是后面不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端进行移动，然后直接清理掉端边界以外的内存，”标记-整理”算法执行示意图如下图:<br><img src="/picture/MarkXZhengLi.png" alt="&quot;标记-整理&quot;算法示意图"></p>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a><strong>4. 分代收集算法</strong></h3><p>当前的商业虚拟机的垃圾收集都是采用”分代收集”(Generational Collection)算法，这种并没有什么心的思想，只是根据对象存活的周期的不同将内存划分为几块，一般是把Java堆中分为新生代和老年代，这样就可以根据每个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集是都发现有大批对象的复制成本就可以完成收集，而老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用”标记-清理”或者”标记-整理”算法来进行回收。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/19/Java垃圾收集算法/" data-id="civ4ygwi6001czwcnauwv6jiu" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/垃圾收集算法/">垃圾收集算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/20/HotSpot的垃圾收集机制算法实现/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nieuwer</strong>
      <div class="article-nav-title">
        
          HotSpot的垃圾收集机制算法实现
        
      </div>
    </a>
  
  
    <a href="/2016/08/14/Java的垃圾收集机制/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">Java的垃圾收集机制</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP-前端-后端/">HTTP 前端 后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hibernate-Java/">Hibernate Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM-Java/">JVM, Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hibernate-Java/">hibernate Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CheckBox/">CheckBox</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Class字节码/">Class字节码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hibernate/">Hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HotSpot垃圾收集算法/">HotSpot垃圾收集算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java内存区域/">Java内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java垃圾回收机制/">Java垃圾回收机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hibernate/">hibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存回收/">内存回收</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端/">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾收集算法/">垃圾收集算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/程序/">程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/索引/">索引</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/CheckBox/" style="font-size: 10px;">CheckBox</a> <a href="/tags/Class字节码/" style="font-size: 10px;">Class字节码</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hibernate/" style="font-size: 10px;">Hibernate</a> <a href="/tags/HotSpot垃圾收集算法/" style="font-size: 10px;">HotSpot垃圾收集算法</a> <a href="/tags/JVM/" style="font-size: 16.67px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java内存区域/" style="font-size: 10px;">Java内存区域</a> <a href="/tags/Java垃圾回收机制/" style="font-size: 10px;">Java垃圾回收机制</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/hibernate/" style="font-size: 16.67px;">hibernate</a> <a href="/tags/内存回收/" style="font-size: 10px;">内存回收</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/后端/" style="font-size: 10px;">后端</a> <a href="/tags/垃圾收集算法/" style="font-size: 10px;">垃圾收集算法</a> <a href="/tags/数据库/" style="font-size: 16.67px;">数据库</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/程序/" style="font-size: 10px;">程序</a> <a href="/tags/索引/" style="font-size: 10px;">索引</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/05/Hibernate框架——二级缓存、Hql语句(四)/">Hibernate框架——二级缓存、Hql语句</a>
          </li>
        
          <li>
            <a href="/2016/11/04/hibernate框架——关系操作(三)/">hibernate框架——关系操作(三)</a>
          </li>
        
          <li>
            <a href="/2016/11/01/Hibernate框架——对象状态(二)/">Hibernate框架——对象状态、缓存(二)</a>
          </li>
        
          <li>
            <a href="/2016/10/05/Hibernate框架——基本操作(一)/">Hibernate框架——基本操作(一)</a>
          </li>
        
          <li>
            <a href="/2016/10/02/高性能场景下-HashMap的优化使用建议/">高性能场景下,HashMap的优化使用建议</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Charse Wang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>